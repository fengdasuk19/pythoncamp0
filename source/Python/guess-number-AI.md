

1. 我仅仅需要 1 个文本框来完成交互，这就要求我要有全局标志变量 `in_play` 来判断是否在游戏中。为什么要用全局标志？因为希望后面把游戏主函数拆分成几个小模块，而这些模块是否执行，则要看是否在游戏中，即都需要通过 1 个标志来通信从而判断状态，从而选用全局变量。

2. 首先考虑到的是：我需要完成以下逻辑

   - 对输入进行判断
        - 输入为 Q？
            - 否：在游戏中？
                - N
                    - 键入是否 非 Y ?
                        - 是：不参与游戏，给与提示
                        - 否：参与游戏，开始新游戏，删除临时数与上下边界，等

                - Y
                    - 用户输入是否 （not 游戏第一步（定义：设定初始猜数范围）） 且 （not 在给定格式（R/H/L）内）？
                        - 是（not 游戏第一步（设定初始猜数范围） 且 not 在给定格式内）: 提示，必须按格式输入，否则游戏无法继续也无法停止
                        - 否（1. not 游戏第一步 且 在给定格式内[事实上，在此分支下，只要 not 游戏第一步，则必定在给定格式内] 2. 游戏第一步[只要是第一步，就无所谓上文所说的「格式」]）: 是 游戏第一步吗 ？（1. or 2. ？）
                            - 是（2. ）：是否整数？（只要是游戏第一步，即边界还未确定结束，就必须输入整数确定边界）

                                    - 是：临时存储该整数，并提示刚输入的数。判断是否存在 2 个边界值？
                                        - 是：提示输入 'BU' or 'BL'，以确认要用新输入的数值替代哪个边界
                                        - 否：是否有 1 个边界值？
                                            - 是：比较刚输入的数和已经存在的边界值，把较大的作为上界，把较小的作为下界，提示输入 C 以确认边界，输入新值以修改边界
                                            - 否：把刚输入的数值赋给下界，提示下一个输入的整数值将与此下界比较，大者成为上界，小者称为下界
                                    - 否：是否 （存在临时整数 且 输入为 'BU' or 'BL' or 'C'）？ 
                                        - 是：判断是否'C'？
                                            - 是：是否已经有了上下界？
                                                - 是：上下界顺序是否正确（上界 > 下界？）
                                                    - 是：边界确定，离开游戏第一步，正式开始游戏
                                                    - 否：提示边界，提示上下界顺序必须正确
                                                - 否：提示当前上下界，提示必须用数值输入边界
                                            - 否：'BU' 还是 'BL'，以确定要把新输入的值赋给哪个变量，提示输入 C 以确认边界，输入新值以修改边界
                                        - 否：是否存在临时整数？
                                            - 是：提示输入'BU' or 'BL' or 'C'
                                            - 否：边界值未确定，必须输入整数值以确定边界
                            - 否（1. ）：（not 游戏第一步 == 已经开始猜数 -> [a. 猜对了  b. 没猜对- b1. 能继续猜 b2. 不能继续猜]）猜对了吗？
                                - 是（1.a）：游戏结束
                                    - 游戏状态返回未开始，随时键入 y 开始新游戏
                                - 否（1.b）：是否达到次数？（判断能否继续玩）
                                    - 是（1.b2 达到次数，不能继续猜）：游戏结束，本轮游戏中 AI 失败
                                    - 否（1.b1 未达到次数，继续猜）：答案比刚猜过的数高吗？
                                        - 是（'H'）：增加 1 次猜数次数，以刚猜过的数字为新下限，猜
                                        - 否（'L'）：增加 1 次猜数次数，以刚猜过的数字为新上限，猜
            - 是：退出游戏，提示

3. 观察以上逻辑结构，确认了

    1. 不需要循环控制：因为游戏交互是通过文本框输入进行事件驱动的
    2. 整个流程很简单，没有重复得很多的模块，因此几乎不需要进行大的模块化，主要流程可在主游戏函数中完成
    3. 因为第 2 点，一开始设想是否在游戏中的标志或许可以直接在游戏主函数内部直接设置，后来否定了这一想法：因为我的游戏主函数即为文本框输入的事件驱动函数，如果每次调用都生成一个新的局部变量并赋值，就无法获知当前游戏状态
    4. 从第 3 点处得到启发：AI 猜数次数上限也要通过全局变量来控制

4. 因此首先要确定在游戏中时的用户输入格式。暂定如下

    - 'R': 猜测正确
    - 'H': 用户所想的数比 AI 猜测的高
    - 'L': 用户所想的数比 AI 猜测的低
    - 'Q': 退出游戏

5. 由于希望键入 'r' 与键入 'R' 的效果一致，因此需要字符串转换方法 `str.upper()`，本以为如果是非字母构成的字符串，无法应用该方法，本打算使用 try-except 语句，但在 CodeSkulptor 与本地环境中均发现这样的转换不会导致返回异常值给系统，因此决定直接用 `if (inp[0].upper() in 'RHLQ')` 来判断输入是否在给定格式中

6. 由于希望取键入的字符串的首位字符来判断选项，一开始直接把变量 `inp` 的首位转换为大写后再赋予 `inp`，之后直接对 `inp` 进行判断。然而，在试图解决游戏开始的边界赋值问题时，出现了一个问题：也就是说，若我直接 `inp = inp[0].upper()`，则如果初始边界值输入为 50，传递给游戏的也只有 5 而已。因此，采用新的变量 `alpha_inp` 来作为判断选项分支的变量，而若在恰当的分支中，则直接把 `inp` 转换为数值，赋予边界，这就解决了初始边界赋值的一个问题

7.  当走到这个分支（在游戏中 -> 用户在游戏第一步 -> 输入是整数 -> 临时存储该整数，并提示刚输入的数 -> 目前只有 1 个边界值 -> 比较刚输入的数和已经存在的边界值，把较大的作为上界，把较小的作为下界，提示输入 C 以确认边界，输入新值以修改边界）时，需要比较刚输入的和已经存在的数值的大小从而赋值给上下界，最开始，代码如下：

        limit_lower = min(limit_lower, temp0)
        limit_upper = max(limit_lower, temp0)

    然而当先输入 0 再输入 -100 时，上下界均被赋值 -100。研究后意识到，第一句将使 `limit_lower` 也变成 -100， 从而在第二句的比较是在 -100 与 -100 进行。因此，有必要使用 2 个中间变量用于保存两者的较大者和较小者，至少需要使用 1 个中间变量用于保存 `limit_lower` 与 `temp0` 中的较小者。（这里有个前提：本程序默认设置为，当 2 个边界都未赋值时，输入的第一个整数将赋值给 `limit_lower`）

8. 判断出猜测错误后，应判断猜测次数是否过了上限，然后才决定是否进一步猜测。而最开始判断猜测次数是否超过上限，使用了语句

        elif (guess_prac == guess_limit)

    这里 `guess_prac` 用于保存实际已经猜测次数，而 `guess_limit` 用于保存猜测次数上限。然而测试时发现，若成功后继续告诉程序，所判断的数字过高或过低，将导致程序错误判断。检查代码，发现每次判断高低时，猜测次数增加 1。而无论成功后继续告诉程序什么信息，应该只有 'y' 能起作用（即重新开始游戏）。因此，应该修改为

        elif (guess_prac >= guess_limit)

    才能保证游戏结束后，无论玩家反馈给程序什么信息，都不会改变刚结束的游戏的结果。

9. 当猜测不正确且可以继续猜测的时候——以猜测数 x 比实际答案 y 高为例，此时，应该在 x 右侧—的区间内进行猜测。该区间的上界则是刚猜测 x 时使用的区间的上界，而下界，一开始我设定为 x，但实际测试时出现了问题：例如区间为[0, 100]，在 AI 使用的方法（二分查找）所能遇到的最坏情况下，这个数是 100，那么猜测序列如下：

    1. 50
    2. 75
    3. 87
    4. 94
    5. 97
    6. 98
    7. 99
    8. 100

    也就是说，直到第 8 次才猜测完成。而对于 100 + 1 - 0 = 101 个元素的集合而言，这个次数不应超过 7 次(power(2, 7) = 128) 。问题在哪里呢？研究了一下，发现 2 个相邻的猜测区间发生了重叠：例如，第 1 次的猜测区间为[0, 100]，第二次则为[50, 100]，而事实上 50 已经被排除，因此没有必要纳入第 2 个猜测区间中。这就是说，第 2 个猜测区间应该是 `[answer_num + 1, limit_upper]` 。这时我们来重新测试一次上面那个最坏情况的例子（* 表示这里与修改前的猜测不同）：

    1. 50
    2. 75
    3. 88(*)
    4. 94
    5. 97
    6. 99
    7. 100

    即恰好在猜测次数上限即第 7 次完成了猜测。这表明，新的算法通过了测试。

10. 最开始将 Q 放在游戏设定输入格式中，与 R/H/L 并列，但后来考虑到，游戏应该在玩家希望停止的任何时候停止，所以把对 Q 的判断移动到最前面，即首先判断是否为 Q，是则退出游戏，否则才开始剩下的判断。这样与把 Q 与 R/H/L 并列并因此大幅修改程序相比较而言，结构会清晰得多，代码会简单得多
 
11. 编写该程序最深刻的体验就是：维护糟糕逻辑的程序，对其修修补补是极其难受的事情，不如重写……嗯是的，我就是把第 2 部分的逻辑修改了半天，最后决定干脆重写，因为修补原来的逻辑实在太难受了。

12. 另外，该程序仍然可以进一步改进：这样编写的只通过 1 个文本框进行交互的程序，只是相当于新制作了一个包含命令行的 GUI 而已，没有利用上 GUI 的友好方便特性。设想了一下，可以增加为 个文本框进行交互，1 个用于输入上界，1 个用于输入下界，通过单击按钮来实现告诉 AI 其所猜测的数字和实际答案之间的大小关系。